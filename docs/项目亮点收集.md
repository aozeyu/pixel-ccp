1）性能：页面加载速度、接口并发量（qps / tps）、接口响应时长等

方法：缓存、并发编程、异步、限流降级熔断、有损服务、CDN、数据压缩等

2）成本：节约系统资源、降低 CPU / 内存 / 磁盘空间 / 带宽占用、节省机器数等

方法：人工分析删除、定期删除、低频存储、淘汰策略、数据压缩等

实际开发项目中，一定要有成本意识！很多同学光说优化，不考虑实际情况，这是一个错误的思维。

3）可用性：尽可能地提高系统对外提供服务的时长，即提高 SLA（3 ~ 5 个 9 的高可用）

参考文章：https://blog.csdn.net/terrychinaz/article/details/112976266

方法：集群、主备、自动故障恢复、监控告警、容灾

4）可靠性：尽可能地让系统提供可靠的服务，不要出现崩溃中断

方法：集群、主备、异常处理、降级、容灾

关于可靠性和可用性的区别：https://blog.csdn.net/HermitSun/article/details/92164226

5）稳定性：接口响应 / 操作处理时长相对固定，成功率高，响应结果保持正常

方法：保证每个服务节点状态正常、性能相当（不要有的机器好有的机器垃圾导致接口时快时慢）；合理规划服务调用链路，不能过长；做好技术选型，避免使用不稳定的第三方依赖

6）容错性：部分节点（服务）出问题时，系统整体依然能够正常提供服务

方法：集群、反向代理、故障转移

7）健壮性：系统不会因为部分异常而整体崩溃

方法：异常处理、进程监控（如 supervisor）

8）系统复杂度：整个系统易于理解，而不是说前人离职、后人无法接手

方法：软件开发原则、设计模式、系统架构设计（如微服务）、开发规范、工作流

9）可维护性：使整个系统结构清晰、利于维护，出了问题也能够快速排查

方法：软件开发原则、设计模式、系统架构设计（如微服务）、开发规范、工作流、抽象复用（组件化模块化）

10）可扩展性：使整个系统能够轻松应对未来新增的需求及业务增长，不会牵一发而动全身

方法：设计模式、架构设计、集群、分库分表、技术选型

11）可观测性：能够随时观察了解系统 / 服务的运行状态、并能快速发现故障和定位异常

方法：系统埋点上报、监控告警（prometheus）、ELK 日志收集、可视化分析（Grafana）

12）可伸缩性：系统根据负载情况动态增加或减少节点，从而能够应对流量高峰、并在空闲时节约成本

方法：K8S + Docker 容器、云原生

13）用户体验：符合用户的使用习惯、提升用户对网站的满意度

方法：网页性能优化、接口性能优化、懒加载、占位符、骨架屏、设备适配、浏览器兼容性、满意度调研（如 NPS）

14）安全性：保证机器、服务、数据库、网络等不被恶意侵入和污染，保证数据和用户隐私的安全

方法：参数校验、常用安全措施（防 XSS、CSRF、SQL 注入等）、网络防护（反 DDOS）、反爬虫、限流、黑白名单、防火墙等



- 短信登录：使用 Redis 实现分布式 Session，解决集群间登录态同步问题，使用 Redis + Token 机制实现单点登录；使用 Hash 代替 String 来存储用户信息，节约了 xx% 的内存并便于单字段的修改。（需要自己实际测试对比数据，节省内存的原因是不用保存序列化对象信息或者 JSON 的一些额外字符串）

- 使用 Redis List 数据结构存储用户点赞信息，并基于 ZSet 实现 TopN 点赞排行，实测相对于 DB 查询性能提升 xx%。（需要自己实际测试对比数据）

- 使用 Redis BitMap 实现用户连续签到统计功能，相对于传统关系库存储，节约 xx% 的内存并提升 xx% 的查询性能。（需要自己实际测试对比数据）

- 在系统用户量不大的前提下，基于推模式实现关注 Feed 流，保证了新点评消息的及时可达，并减少用户访问的等待时间。

- 优惠券秒杀：使用 Redis + Lua 脚本实现库存预检，并通过 Stream 队列实现订单的异步创建，解决了超卖问题、实现一人一单。实现相比传统数据库，秒杀性能提高了 xx%。（需要自己实际测试对比数据）

- 对 Redis 的所有 key 设置 N + n 的过期时间，从而合理使用内存并防止缓存雪崩；针对热点店铺缓存，使用逻辑过期（或自动续期）机制解决缓存击穿问题，防止数据库宕机。

- 使用 Redis 的 Geo + Hash 数据结构分类存储附近商户，并使用 Geo Search 命令实现高性能商户查询及按距离排序，实测相对于传统 DB 查询 + 业务层计算的方式，性能提升 xx%。

- 使用 Redis Set 数据结构实现用户关注、共同关注功能（交集），实测相对于 DB 查询性能提升 xx%，并使用 Redis AOF + 业务层日志防止关注数据丢失。（理解 AOF 和 RDB 持久化机制后再写这点）

- 基于 Spring Scheduler 实现对热点数据的定期检测和缓存预加载，提升用户的访问体验，并通过 Redisson 分布式锁保证集群中同一时刻的定时任务只执行一次。

- 基于 Spring Cloud + Nacos 实现项目的微服务化，划分项目为公共、用户、订单等服务，提高项目的可扩展性和容错性。

- 使用 Spring Cloud Gateway 实现微服务请求转发，并在网关层全局解决跨域、用户鉴权、黑白名单、内网服务保护等问题，降低开发成本、提高安全性。

- 使用 JWT 实现单点登录，并支持手机验证码、OAuth2 微信扫码登录，提高用户真实性和登录安全性

- 对接微信支付 API 实现预约付款，并通过全局唯一 id 以及支付 / 退款记录表的设计保证了支付操作的幂等性

- 使用 MongoDB 代替 MySQL 存储读多写少的半结构化数据（如医院信息），实测查询性能提高 xx%。（自己用 JMeter 测试一下）

- 为应对流量高峰，使用 RabbitMQ 将下单减库存等耗时操作异步化，提升下单接口单机 QPS（xx 至 xx）

- 使用 Spring Scheduler 实现定时预约提醒功能，并使用 RabbitMQ 实现定时服务和通知服务的解耦，提高服务可维护性。

- 使用 Nuxt 框架实现服务端渲染，提高网页首屏加载速度（xx 秒至 xx 秒）。

- 基于静态 ThreadLocal 封装了线程隔离的全局上下文对象，便于在请求内部存取用户信息，减少用户远程查询次数。

- 使用 Knife4j + Swagger 自动生成后端接口文档，并通过编写 ApiOperation 等注解补充接口注释，避免了人工编写维护文档的麻烦。

- 为省去重复编写用户校验的麻烦，基于 WebFilter 实现全局登录校验；并通过 AntPathMatcher 来匹配动态请求路径，实现灵活的可选鉴权。

- 为保证数据的完整性和一致性，使用 @Transactional 实现数据库事务，并配置 rollbackFor = Exception.class 来支持受检异常的事务回滚。

- 为提高 XX 信息页加载速度，基于 Spring Cache 注解 + Redis 实现对 XX 信息的自动缓存，大幅降低数据库压力的同时将接口响应耗时由 0.8s 减少至 50ms（数值自己再测一下）

- 为降低用户注册成本、保证用户真实性，二次封装 XX 云 SDK 接入短信服务，并通过 Redis 来集中缓存验证码，防止单手机号的重复发送。



